# 堆排序 - （概念性还未补充）

## 什么是堆排序

## 一些名词概念

1. 大顶堆：
2. 小顶堆：
3. 完全二叉树

## 堆排序实现

> 1.给原数组左补位

- 为了让数组索引与树索引对应，树是以 1 开始的
nums -> [0] + nums

```python
    # 使用deque是为了方便左补位
    queue = deque(nums)
    queue.appendleft(0)
```

> 2.将数组转换成大顶堆

- 这里实际是将树中的每一颗小树换成大顶堆，因此需要循环每个小树的根节点
- 转换顺序是 右 -> 左， 下 -> 上
- 如果在转换上面小树的时候，对下面的产生了影响，则应该使用while一直转换到底
- 完全二叉树，从上至下，根节点索引 rootIndex 为 [1,2,3...n/2]
- 每个根节点的儿子节点是 2 * rootIndex
- 操作完成后，数组索引为 1 的元素就是数组中的最大值

```python
    # while的作用是寻找转换后的儿子节点是不是还有要转换的儿子
    while son <= length:
        if nums[fatherIndex] >= nums[son]:
            break
        else:
            # 转换
            ...
            # 将之前的儿子节点当成爸爸，用来while中判断他有没有儿子
            fatherIndex = son
            son = 2 * fatherIndex
```

> 3.交换 + 大顶堆

- 将数组的第一个与第 i 个交换，注意是倒序交换，即从倒数第一个开始交换，i = [n - 1, 2]
- 重新构造大顶堆，此时因为只改变了root节点，因此只需要对root节点进行一次大顶堆操作即可，操作过程中如果对下面的节点有影响，需要循环处理到最后一个节点
- 重复上述两步，直到全部交换完，交换次数是 len(原数组) - 1 次
- 每次交换完，最大的数已经排到最后，因此下次交换不需要再考虑他，数组总长度可以减一

```python

    for i in range(L - 1): # len(原数组) - 1
        # 交换
        self.swap(queue, 1, L - i)
        # 对root节点重新构造大顶堆
        self.heapAdjust(queue, 1, L - 1 - i)
```

> 4.去掉补位

```python
    nums[:] = [queue[i] for i in range(1, L + 1)]
```
